# Program initialization and execution

## The zero value
当为变量分配内在的时候，可以通过使用声明语句，或者调用new函数，或者当一个新的值被创建的时候，可以通过组合语句，或者调用make，并且如果没有显示的初始化值的话，变量或者值会被赋予一个默认的值。变量或者值的每一个元素会被设为该类型的默认0值：布尔类型是false，整形是0，浮点类型是0.0，字符串是""，指针、函数、接口、slice、channel、map是nil。初始化是递归完成的，例如，如果没有初始化值被使用的话，一个结构体类型的数组的每一个元素的每一个域都被对初始化为对应类型的0值。

下面的两个声明是等价的
`var i int`
`var i int = 0`

`type T struct {i int; f float64; next *T}`
`t := new(T)`
`t.i == 0`
`t.f == 0.0`
`t.next == nil`

如果是`var t T 刚和上面的初始化结果是一样的`

## Package initialization

在golang的package内，package级别变量的初始化由声明的顺序决定，但是必须要在他们依赖的变量初始化完之后初始化

更精确点来说，如果一个pakcage级别的变量还没有被初始化，并且也不存在初始化表达式或者初始化表达式没有依赖未初始化的变量，那就说这个package级别的变量*可被初始化*。初始化的进行是通过不断的重复初始化*可被初始化的变量*,直到系统中不存在*可被初始化的变量*

如果初始化的进行过程已经结束，但是这时候还存在未被初始化的*可被初始化的变量*，说明这些变量陷入了循环初始化，意思就是出现了初始化依赖死循环，这样的程序是无效的。

声明在多个文件中的变量的声明顺序是由呈现给编译器的包含这些变量的文件的顺序决定的，首先声明的是第一个文件中的变量，其次是第二文件，然后依次...

变量的依赖分析并不依赖于实际的常量值，依赖的仅仅是对他们标识符的引用。例如，如果变量A的初始化表达式引用了一个函数B,而B函数的函数体内引用了变量C，那么A依赖于B。明确来讲：
> 1 A引用了一个变量或者函数，那A就是一个表示那个变量或者函数的标识符
> 2 A引用了一个方法m，那A就是一个方法值或者一个t.m形式的方法表达式，在t.m表达式里，t的类型不是一个接口类型，并且方法m存在于t的方法集中。t.m代表的函数是否被调用是不重要的
> 3 如果一个变量，函数或者方法x的初始化表达式或者方法/函数体内引用了y或者一个引用y的函数或者方法，刚变量x依赖y

依赖分析在每个包里都会被执行，并且只会考虑那些声明在当前包中并且引用了变量、函数、方法的package级别的变量

例如，给予下面的声明
```
	var (
    	a = c + b
        b = f()
        c = f()
        d = 3
    )
    func f() int {
    	d++
        return d
    }
```
上面声明的初始化顺序是d，b，c，a


变量也可以被声明在package范围内的init函数初始化，该init函数没有参数，没有返回值
`func init() {...}`

每一个包，甚至是一个单独的文件都可以存在多个init函数。在package范围内，init标识符只能被用来声明init函数，而且init标识符的本身是没有被声明的。因此，init函数是不能够在程序的任何地方被调用的。

如果一个package没有导入其他的package，首先初始化所有的package级别的变量，然后按init函数出现的顺序依次调用init函数，如果init函数分布在一个package的多个文件中，那就按呈现给编译器的顺序来调用。如果一个package有导入其他的package，首先初始化导入的package。如果多个package导入了同一个package，被导入的同一个package只会被初始化一次。合理构造package的导入，来确保这其中不会出现循环初始化依赖

package初始化----变量的初始化和init函数的调用有顺序的发生在一个goroutine内，并且一个package只会发生一次。init函数可能会生成其他的goroutines，这些生成的goroutines可以和初始化代码并发的运行。package初始化总是会将init函数顺序化，直到上一个init函数成功返回才会接着调用下一个init函数

为了确保初始化行为的可复用性，构建系统更倾向于将一个package中的多个文件以文件名的词汇顺序呈现给编译器

## Program execution
一个完整的程序是通过链接一个唯一的，未被导入的main package被创建的，这个main package传递性的导入了（main->a->b）所有的它需要的packages. main package开关必须包含package main子句，并且声明一个没有参数也没有返回值的main函数`func main() { ... }`

程序的执行通过初始化main package然后调用main函数开始。当函数调用return后，程序退出。它并不会等待其他的（非main）goroutines执行完成
